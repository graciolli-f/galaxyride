<!DOCTYPE html>
<html>
<head>
    <title>Cosmic Vortex Example</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const config = {
            particles: 2000,
            arms: 1,          // Number of spiral arms
            baseHue: 300,     // Base color (purple)
            armWidth: 0.05,    // Width of spiral arms
            rotationSpeed: 0.002,
            expansionSpeed: 0.3,
            particleSize: .5,
            tailLength: 0.01,
            centerGlow: true
        };

        const particles = [];
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // Create particles in a spiral galaxy pattern
        for(let i = 0; i < config.particles; i++) {
            // Calculate spiral position
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * Math.min(canvas.width, canvas.height) * 0.4;
            
            // Add spiral arm effect
            const armOffset = (angle % (Math.PI * 2 / config.arms)) / (Math.PI * 2 / config.arms) - 0.5;
            const distanceOffset = Math.exp(-Math.abs(armOffset) / config.armWidth) * 50;

            particles.push({
                x: centerX + Math.cos(angle) * (distance + distanceOffset),
                y: centerY + Math.sin(angle) * (distance + distanceOffset),
                angle: angle,
                distance: distance,
                size: Math.random() * config.particleSize + 1,
                speed: (0.1 + Math.random() * 0.2) * config.rotationSpeed,
                hue: config.baseHue + Math.random() * 60 - 30,
                opacity: Math.random() * 0.5 + 0.5,
                trail: []
            });
        }

        function draw() {
            // Create fade effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw center glow
            if (config.centerGlow) {
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 200);
                gradient.addColorStop(0, `hsla(${config.baseHue}, 100%, 50%, 0.3)`);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Update and draw particles
            particles.forEach(p => {
                // Store position for trail
                p.trail.push({ x: p.x, y: p.y });
                if (p.trail.length > 20) {
                    p.trail.shift();
                }

                // Update position
                p.angle += p.speed * (1 - p.distance / 1000);
                p.distance -= config.expansionSpeed;

                if (p.distance < 0) {
                    p.distance = Math.min(canvas.width, canvas.height) * 0.4;
                    p.trail = [];
                }

                // Calculate new position with spiral arm offset
                const armOffset = (p.angle % (Math.PI * 2 / config.arms)) / (Math.PI * 2 / config.arms) - 0.5;
                const distanceOffset = Math.exp(-Math.abs(armOffset) / config.armWidth) * 50;
                
                p.x = centerX + Math.cos(p.angle) * (p.distance + distanceOffset);
                p.y = centerY + Math.sin(p.angle) * (p.distance + distanceOffset);

                // Draw particle trail
                if (p.trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(p.trail[0].x, p.trail[0].y);
                    
                    for(let i = 1; i < p.trail.length; i++) {
                        ctx.lineTo(p.trail[i].x, p.trail[i].y);
                    }

                    ctx.strokeStyle = `hsla(${p.hue}, 100%, 50%, ${p.opacity})`;
                    ctx.lineWidth = p.size;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                }
            });

            requestAnimationFrame(draw);
        }

        draw();

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            centerX = canvas.width / 2;
            centerY = canvas.height / 2;
        });
    </script>
</body>
</html> 