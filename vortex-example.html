<!DOCTYPE html>
<html>
<head>
    <title>MotionCanvas Vortex Example</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const config = {
            particles: 2000,
            minRadius: 5,
            maxRadius: 300,
            speed: 0.02,
            particleSize: 2,
            colorStart: '#ff0088',
            colorEnd: '#00ffff',
            inwardSpeed: 0.5,
            trail: 8,
            loop: false,          // Set to true to make particles loop back to outside
            allParticlesActive: true  // New flag to track if all particles are still active
        };

        const particles = [];
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // Helper function to interpolate colors
        function interpolateColor(color1, color2, factor) {
            const hex2rgb = (hex) => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return [r, g, b];
            };

            const c1 = hex2rgb(color1);
            const c2 = hex2rgb(color2);
            
            const r = Math.round(c1[0] + (c2[0] - c1[0]) * factor);
            const g = Math.round(c1[1] + (c2[1] - c1[1]) * factor);
            const b = Math.round(c1[2] + (c2[2] - c1[2]) * factor);
            
            return `rgb(${r}, ${g}, ${b})`;
        }

        // Initialize particles
        function initializeParticles() {
            particles.length = 0;  // Clear existing particles
            config.allParticlesActive = true;

            for(let i = 0; i < config.particles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = config.maxRadius;
                particles.push({
                    x: centerX + Math.cos(angle) * radius,
                    y: centerY + Math.sin(angle) * radius,
                    angle: angle,
                    radius: radius,
                    speed: config.speed * (0.5 + Math.random() * 0.5),
                    trail: [],
                    active: true
                });
            }
        }

        initializeParticles();

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let activeCount = 0;

            particles.forEach(p => {
                if (!p.active) return;
                activeCount++;

                p.trail.push({ x: p.x, y: p.y });
                if (p.trail.length > config.trail) {
                    p.trail.shift();
                }

                p.angle += p.speed * (1 + (config.maxRadius - p.radius) / config.maxRadius);
                p.radius -= config.inwardSpeed;

                p.x = centerX + Math.cos(p.angle) * p.radius;
                p.y = centerY + Math.sin(p.angle) * p.radius;

                if (p.trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(p.trail[0].x, p.trail[0].y);
                    
                    for(let i = 1; i < p.trail.length; i++) {
                        ctx.lineTo(p.trail[i].x, p.trail[i].y);
                    }

                    const colorFactor = 1 - (p.radius / config.maxRadius);
                    ctx.strokeStyle = interpolateColor(config.colorStart, config.colorEnd, colorFactor);
                    ctx.lineWidth = config.particleSize;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                }

                if (p.radius < config.minRadius) {
                    if (config.loop) {
                        p.radius = config.maxRadius;
                        p.angle = Math.random() * Math.PI * 2;
                        p.trail = [];
                    } else {
                        p.active = false;
                    }
                }
            });

            // Check if all particles are inactive
            if (!config.loop && activeCount === 0 && config.allParticlesActive) {
                config.allParticlesActive = false;
                setTimeout(() => {
                    initializeParticles();
                }, 1000);  // Wait 1 second before restarting
            }

            requestAnimationFrame(draw);
        }

        draw();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html> 