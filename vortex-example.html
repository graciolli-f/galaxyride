<!DOCTYPE html>
<html>
<head>
    <title>MotionCanvas Vortex Example</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const config = {
            particles: 2000,
            minRadius: 5,
            maxRadius: 300,
            speed: 0.02,
            particleSize: 2,
            colorStart: '#ff0088',
            colorEnd: '#00ffff',
            inwardSpeed: 0.5,
            trail: 8
        };

        const particles = [];
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // Helper function to interpolate colors
        function interpolateColor(color1, color2, factor) {
            const hex2rgb = (hex) => {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return [r, g, b];
            };

            const c1 = hex2rgb(color1);
            const c2 = hex2rgb(color2);
            
            const r = Math.round(c1[0] + (c2[0] - c1[0]) * factor);
            const g = Math.round(c1[1] + (c2[1] - c1[1]) * factor);
            const b = Math.round(c1[2] + (c2[2] - c1[2]) * factor);
            
            return `rgb(${r}, ${g}, ${b})`;
        }

        // Initialize particles
        for(let i = 0; i < config.particles; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = config.maxRadius;
            particles.push({
                x: centerX + Math.cos(angle) * radius,
                y: centerY + Math.sin(angle) * radius,
                angle: angle,
                radius: radius,
                speed: config.speed * (0.5 + Math.random() * 0.5),
                trail: []
            });
        }

        function draw() {
            // Add semi-transparent black for trail effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            particles.forEach(p => {
                // Store position for trail
                p.trail.push({ x: p.x, y: p.y });
                if (p.trail.length > config.trail) {
                    p.trail.shift();
                }

                // Update position
                p.angle += p.speed * (1 + (config.maxRadius - p.radius) / config.maxRadius);
                p.radius -= config.inwardSpeed;

                // Calculate new position
                p.x = centerX + Math.cos(p.angle) * p.radius;
                p.y = centerY + Math.sin(p.angle) * p.radius;

                // Draw trail
                if (p.trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(p.trail[0].x, p.trail[0].y);
                    
                    for(let i = 1; i < p.trail.length; i++) {
                        ctx.lineTo(p.trail[i].x, p.trail[i].y);
                    }

                    // Color based on radius
                    const colorFactor = 1 - (p.radius / config.maxRadius);
                    ctx.strokeStyle = interpolateColor(config.colorStart, config.colorEnd, colorFactor);
                    ctx.lineWidth = config.particleSize;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                }

                // Reset particle if it reaches center
                if (p.radius < config.minRadius) {
                    p.radius = config.maxRadius;
                    p.angle = Math.random() * Math.PI * 2;
                    p.trail = [];
                }
            });

            requestAnimationFrame(draw);
        }

        draw();

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html> 