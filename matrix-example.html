<!DOCTYPE html>
<html>
<head>
    <title>MotionCanvas Matrix Example</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const config = {
            fontSize: 14,
            columns: Math.floor(window.innerWidth / 14),  // Based on font size
            drops: [],
            chars: "ｦｱｳｴｵｶｷｹｺｻｼｽｾｿﾀﾂﾃﾅﾆﾇﾈﾊﾋﾎﾏﾐﾑﾒﾓﾔﾕﾗﾘﾜ日0123456789"  // Katakana + numbers
        };

        // Initialize drops
        for(let i = 0; i < config.columns; i++) {
            config.drops[i] = {
                x: i * config.fontSize,
                y: Math.random() * canvas.height * -1,
                speed: 1 + Math.random() * 2,
                length: 10 + Math.floor(Math.random() * 20),
                chars: []
            };
        }

        function draw() {
            // Add semi-transparent black to create fade effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = config.fontSize + 'px monospace';
            
            // Update and draw each drop
            config.drops.forEach(drop => {
                // Add new character at the head of the drop
                if (drop.chars.length < drop.length) {
                    drop.chars.unshift(config.chars[Math.floor(Math.random() * config.chars.length)]);
                }

                // Remove characters that are too old
                if (drop.chars.length > drop.length) {
                    drop.chars.pop();
                }

                // Draw characters
                drop.chars.forEach((char, i) => {
                    // First character (bright)
                    if (i === 0) {
                        ctx.fillStyle = '#ffffff';
                        ctx.shadowColor = '#00ff00';
                        ctx.shadowBlur = 6;
                    } else {
                        // Trail characters (fading green)
                        const alpha = 1 - (i / drop.length);
                        ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`;
                        ctx.shadowBlur = 0;
                    }

                    ctx.fillText(char, drop.x, drop.y - (i * config.fontSize));
                });

                // Move drop down
                drop.y += drop.speed;

                // Reset drop if it's off screen
                if (drop.y - (drop.length * config.fontSize) > canvas.height) {
                    drop.y = Math.random() * canvas.height * -1;
                    drop.chars = [];
                    drop.speed = 1 + Math.random() * 2;
                    drop.length = 10 + Math.floor(Math.random() * 20);
                }
            });

            requestAnimationFrame(draw);
        }

        draw();

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            config.columns = Math.floor(window.innerWidth / config.fontSize);
            
            // Reinitialize drops for new width
            config.drops = [];
            for(let i = 0; i < config.columns; i++) {
                config.drops[i] = {
                    x: i * config.fontSize,
                    y: Math.random() * canvas.height * -1,
                    speed: 1 + Math.random() * 2,
                    length: 10 + Math.floor(Math.random() * 20),
                    chars: []
                };
            }
        });
    </script>
</body>
</html> 